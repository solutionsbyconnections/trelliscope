---
output: github_document
---

TODO: - Document `add_meta_tags()` - Document default `write_panels(..., force = FALSE)`

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# trelliscope

<!-- badges: start -->

[![R-CMD-check](https://github.com/trelliscope/trelliscope/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/trelliscope/trelliscope/actions/workflows/R-CMD-check.yaml) [![Codecov test coverage](https://codecov.io/gh/trelliscope/trelliscope/branch/main/graph/badge.svg)](https://app.codecov.io/gh/trelliscope/trelliscope?branch=main) [![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)

<!-- badges: end -->

This repository contains an rewrite of the trelliscopejs R package, now simply called trelliscope.

## Installation

You can install the development version of trelliscope from [GitHub](https://github.com/) with:

``` r
devtools::install_github("trelliscope/trelliscope")
```

## Overview

Trelliscope provides a simple mechanism to make a collection of visualizations and display them as interactive [small multiples](https://en.wikipedia.org/wiki/Small_multiple) similar to how faceting in ggplot2 works. This is a useful general visualization technique for many scenarios, particularly when looking at a somewhat large dataset comprised of many natural subsets. However, where Trelliscope differentiates itself from traditional faceting is in layout and interactivity. Traditionally, facets appear in one large plot that becomes noisy with too many groups. Trelliscope on the other hand allows you to generate a large number of plots in an interactive window where the plots can be filtered and sorted based on meta data and paged through with a limited number of plots at a time.

The Trelliscope R package provides utilities to create the visualizations, specify metadata about the visualizations that can be used to interactively navigate them, and specify other aspects of how the visualization viewer should behave. These specifications are given to a Trelliscope viewer written in JavaScript.

### Data frames of visualizations

The basic principle behind the design of the R package is that you specify a collection of visualizations as a data frame, with one column representing the plot (either as a plot object such as ggplot or as a reference to an image such as a png, svg, or even html file), and the other columns representing metadata about each visualization.

This package provides utilities to help build these data frames and then explore them in an interactive viewer.

### Example

As a simple example, let's consider the `gapminder` dataset that originally comes with the `gapminder` package. We have included a modified version of the dataset with the Trelliscope package.

```{r}
library(trelliscope)

gapminder
```

This data provides statistics such as life expectancy annually for 123 countries.

Suppose we want to visualize life expectancy vs. year for each country. The fastest way to do this is to build the plot in ggplot and then run `facet_panels()` similarly to how you would use `facet_wrap()`.

```{r}
library(trelliscope)
suppressPackageStartupMessages(
  library(tidyverse, warn.conflicts = FALSE) # for ggplot2, tidyr, dplyr, purrr
)

ggplot(gapminder, aes(year, lifeExp)) +
  geom_point() +
  facet_panels(~ country + continent)
                   
```

This creates a quick Trelliscope grouped by country and continent but it lacks customization in the naming and layout as well as any additional metadata for sorting and filtering. We can fix this by expanding on the `facet_panels()` function.

If you are plotting with ggplot2, there are several benefits to using `facet_panels()`. First, it fits more naturally into the ggplot2 paradigm, where you can build a Trelliscope visualization exactly as you would with building a ggplot2 visualization. Second, you can make use of the `scales` argument in `facet_panels()` (which behaves similarly to the same argument in `facet_wrap()`) to ensure that the x and y axis ranges of your plots behave the way you want. The default is for all plots to have the same `"fixed"` axis ranges. This is an important consideration in visualizing small multiples because if you are making visual comparisons you often want to be comparing things on the same scale.

### Creating a nested data frame for further customization

A large part of the power for trelliscope lies in it's ability to customize the interface using metadata that corresponds with the plots. In order to include this, we expand upon our example from earlier using `facet_panels()`. We can take the plots generated for each facet and store them, along with the original data used to create them, in a nested data frame using `nest_panels()`.

```{r}
panel_df <- (ggplot(gapminder, aes(year, lifeExp)) +
               geom_point() +
               facet_panels(~ country + continent)) |>
  nest_panels()
```

This creates a nested data frame with columns for our grouping variables, country and continent, as well as a nested data column and a panel column which contains our plots for each row of the data frame. You can view the plot for any one row by calling the panel column and the index number of the row you want to look at. For example, if you wanted to see the generated plot for the second row, Albania, you would run the following code.

```{r}
panel_df$panel[[2]]
```

Now that we have a nested data frame including our plots, we can write a Trelliscope with more customization.

We begin by first converting our nested data frame into a Trelliscope data frame. This special data frame will allow the final Trelliscope to recognize our nested panels as visualizations to be shown in the final product. To convert our current data frame to a Trelliscope data frame we use the `as_trelliscope_df()` function. We can also name our Trelliscope, set the path where the final Trelliscope will be stored, and provide other classifying information like descriptions and tags at this stage. For now we will simply name our Trelliscope and store it in a new directory simply called "trelliscope".

```{r}

trell_df <- as_trelliscope_df(panel_df, name = "Gapminder", path = "trelliscope")
```

To then write the panels in preparation for adding them to the Trelliscope display we run `write_panels()` followed by `write_trelliscope()` to compile the Trelliscope in the JavaScript viewing app.

To then view the Trelliscope, use `view_trelliscope()`. This function will either open up the most recently created Trelliscope or open a Trelliscope object that is passed into the function.

```{r}
trell <- write_panels(trell_df) |>
  write_trelliscope()

view_trelliscope(trell)
```

### Including meta data

We've shown how to create Trelliscopes in two ways, through the basic use of `facet_panels()` and the more customizable use of `nest_panels()`, but we have so far neglected one of Trellisccope's greatest features; the ability to sort and filter on meta data. We are going to add onto our example from earlier by joining meta data to our nested data frame from earlier that we can then use for sorting and filtering in the Trelliscope viewing app.

Below is the compelte example we worked out earlier in a single chunk.

```{r}
panel_df <- (ggplot(gapminder, aes(year, lifeExp)) +
               geom_point() +
               facet_panels(~ country + continent)) |>
  nest_panels()

trell_df <- as_trelliscope_df(panel_df, name = "Gapminder", path = "trelliscope")

trell <- write_panels(trell_df) |>
  write_trelliscope()

view_trelliscope(trell)
```

If you look at `panel_df` you should see a data set where each row is a unique country along with it's corresponding continent. Any meta data we provide needs to match that level of granularity ergo each row of our meta data corresponds to a unique country and continent. Those familiar with the tidyverse should be able to quickly create a data set at that level of granularity using `group_by()` and `summarise()`. We will now make a data frame at the country/continent level with the following variables: `mean_lifeExp`, `min_lifeExp`, and `meanGDP.`

```{r}
meta_df <- gapminder |>
  group_by(country, continent) |>
  summarise(
    mean_lifeExp = mean(lifeExp),
    min_lifeExp = min(lifeExp),
    meanGDP = mean(gdpPercap),
    .groups = "drop"
  )
```

With our meta data frame created we can now join it to the original nested data frame with our panels stored in it to create a complete data frame.

We insert the code into our block from earlier to join into a complete data set and finish constructing the Trelliscope.

```{r}
panel_df <- (ggplot(gapminder, aes(year, lifeExp)) +
               geom_point() +
               facet_panels(~ country + continent)) |>
  nest_panels()

meta_df <- gapminder |>
  group_by(country, continent) |>
  summarise(
    mean_lifeExp = mean(lifeExp),
    min_lifeExp = min(lifeExp),
    meanGDP = mean(gdpPercap),
    .groups = "drop"
  )

trell_df <- left_join(panel_df, meta_df) |>
  as_trelliscope_df(name = "Gapminder", path = "trelliscope")

trell <- write_panels(trell_df) |>
  write_trelliscope()

view_trelliscope(trell)
```

Including the meta data in the data set now allows for sorting and filtering in the Trelliscope app on those meta variables. You will find more examples below delving into how you can further customize Trelliscope.

There is a lot going on in the code example above that should be familiar if you have experience with Tidyverse packages such as dplyr and tidyr. A great resource for this can be found in ["R for Data Science"](https://r4ds.had.co.nz/index.html), particularly [this chapter](https://r4ds.had.co.nz/many-models.html) which mimics many of the ideas here of nesting and list columns with the same data set.

Note that although the tidyverse provides many helpful functions, it does not matter what package or approach you use as long as you can get your data into the form of a data frame with one row per visualization and a visualization column. It's worth noting that the visualization column does not have to be a ggplot. It can be static images, plotly visualizations, or any other html based visualization.

### Finer control

So far we have seen the following general set of steps to create a trelliscope display:

Starting with a data frame of raw data, `df`, we can create a data frame of visualizations using using `facet_panels()`:

``` r
df |>
  (ggplot(...) + ... + facet_panels()) |>
  nest_panels() |>
  as_trelliscope_df() |>
  write_trelliscope()
```

In between `as_trelliscope_df() |> write_trelliscope()`, there are many functions we can call that give us better control over how our display looks and behaves. These include the following:

-   `write_panels()`: allows finer control over how panels are written (e.g. plot dimensions, file format, etc.)
-   `add_meta_defs()`: specify metadata variable definitions (e.g. plain text variable descriptions, types, tags)
-   `add_meta_labels()`: as an alternative to fully specifying metadata variable definitions, this is a convenience function to only supply labels for all of the variables
-   `set_default_labels()`, `set_default_layout()`, `set_default_sort()`, `set_default_filters()`: specify the initial state of the display
-   `add_view()`: add any number of pre-defined "views" that navigate the user to specified states of the display
-   `add_inputs()`: specify inputs that can collect user feedback for each panel in the display

Each of these functions takes a trelliscope data frame (created with `as_trelliscope_df()`) and returns a modified trelliscope data frame, making them suitable for chaining.

To illustrate some of these, let's create a trelliscope data frame:

```{r}
x <- (ggplot(aes(year, lifeExp), data = gapminder) +
  geom_point() +
  facet_panels(~ continent + country)) |>
  nest_panels()

y <- gapminder |>
  group_by() |>
  summarise(
    mean_lifeExp = mean(lifeExp),
    min_lifeExp = min(lifeExp),
    meanGDP = mean(gdpPercap),
    .groups = "drop"
  ) |>
  mutate(
    wiki_link = paste0("https://en.wikipedia.org/wiki/", country)
  )

z <- left_join(x, y) |>
  as_trelliscope_df(name = "life expectancy")

z
```

As you can see, z is still a data frame. To see more information about trelliscope-specific settings, you can use `show_info()`:

```{r}
show_info(z)
```

```{=html}
<!-- #### `write_panels()`

The optional chain function `write_panels()` can be used to have finer control over how panels get written to disk. It also can give the advantage of making panel writing a separate step so that it does not need to be repeated every time a display might be modified.

The main arguments are `width`, `height`, and `format`. The `width` and `height` are specified in pixels, and are mainly to provide information about the plot's aspect ratio and size of text and glyphs. The actual dimensions of the plot as shown in the viewer will vary (the aspect ratio remains fixed) depending on how many plots are shown at once.

The file format can be either `png` or `svg`. This is ignored if the plot column of the data frame is an htmlwidget such as a ggplotly plot.

disp <- disp |>
  write_panels(width = 800, height = 500, format = "svg")

Once the panels are written, a note is made in the `disp` object so that it knows it doesn't have to be done with writing out the display. -->
```
#### `add_meta_defs()`

Each metadata variable can have additional attributes specified about it that enhance the user's experience when viewing the display. The main attribute is the metadata variable label. Without supplying a label, variables will appear in the viewer by their variable names (e.g. `mean_gdp` vs. a label such as `Mean of yearly GDP per capita (US$, inflation-adjusted)`).

Additionally, we can specify the variable type, specify tags (e.g. "demographics", "geography", etc.) that can make variables easier to navigate in the viewer when there are many of them, and other type-specific parameters.

Each metadata variable can be specified by using a helper function that specifies its type. Each of these has the arguments `varname`, `label`, and `tags` (denoted below with `...`) and any additional arguments which are either self-explanatory or can be further studied by looking at the function help files.

-   `meta_string(...)`: indicates the variable is a string
-   `meta_factor(..., levels)`: indicates the variable is a fator - the difference between this and a string is that the provided `levels` are used to determine the sorting order, etc. as opposed to alphabetically with strings
-   `meta_number(..., digits, locale)`: indicates a numeric variable
-   `meta_currency(..., code)`: indicates a currency variable - essentially the same as a number but will be displayed differently in the app
-   `meta_date(...)`: indicates a date variable
-   `meta_datetime(...)`: indicates a datetime variable
-   `meta_href(...)`: indicates a variable that contains a hyperlink to another web source - it will be rendered as a hyperlink
-   `meta_geo(..., latvar, longvar)`: indicates geographic coordinates (currently not supported)
-   `meta_graph(..., idvarname, direction)`: indicates network graph relationships between variables (currently not supported)

We can provide these specifications by calling `add_meta_defs()` on our trelliscope data frame. This function takes as arguments any number of `meta_*()` function calls. For example, let's build up our object to include some of these metadata variable specifications:

```{r}
z <- z |>
  add_meta_defs(
    meta_number("mean_gdp",
      label = "Mean of annual GDP per capita (US$, inflation-adjusted)",
      digits = 2),
    meta_href("wiki_link", label = "Wikipedia country page")
  )

z
```

If metadata variable definitions are not provided (such as here where we don't provide explicit definitions for `country`, `continent`, `min_lifeexp`, and `mean_lifeexp`), they are inferred at the time the display is written. The inference usually works pretty well but it cannot infer labels and is not able to detect things like currencies.

#### `add_meta_labels()`

Often the metadata inference works well enough that we might just want to provide labels for our metadata variables and skip the more formal metadata variable definition. We can do this with `add_meta_labels()`. This function simply takes a named set of parameters as input, with the names indicating the variable name and the values indicating the labels. For example:

```{r}
z <- z |>
  add_meta_labels(
    mean_lifeexp = "Mean of annual life expectancies",
    min_lifeexp = "Lowest observed annual life expectancy"
  )

z
```

We still haven't specified labels for `country` and `continent`. If labels are not provided, they will be set to the variable name. In the case of these two variables, the variable name is clear enough to not need to specify the labels.

#### `set_default_labels()`

By default, the "key columns" will be shown as labels. If we'd like to change what labels are shown when the display is opened, we can use `set_default_labels()`, e.g.:

```{r}
z <- z |>
  set_default_labels(c("country", "continent", "wiki_link"))
```

#### `set_default_layout()`

We can also set the default panel layout:

```{r}
z <- z |>
  set_default_layout(nrow = 3, ncol = 5)
```

#### `set_default_sort()`

We can set the default sort order with `set_default_sort()`:

```{r}
z <- z |>
  set_default_sort(c("continent", "mean_lifeexp"), dir = c("asc", "desc"))
```

#### `set_default_filters()`

We can set the default filter state with `set_default_filters()`. Currently there are two different kinds of filters:

-   `filter_range(varname, min = ..., max = ...)`: works with numeric, date, or datetime variables
-   `filter_string(varname, values = ...)`: works with factor or string variables

```{r}
z <- z |>
  set_default_filters(
    filter_string("continent", values = "Africa"),
    filter_range("mean_lifeexp", max = 50)
  )
```

More types of filters are planned.

#### `add_view()`

Views are predefined sets of state that are made available in the viewer to help the user get to regions of the display that are interesting in different ways. You can add a view chaining the display through the `add_view()` function.

`add_view()` takes a `name` as its first argument, and then any number of state specifications. The functions available to set the state are the following:

-   `state_layout()`
-   `state_labels()`
-   `state_sort()`
-   `filter_string()`
-   `filter_range()`

The `state_*()` functions have the same parameters as and behave similarly to their `set_*()` counterparts except that unlike those, these do not receive a Trelliscope data frame and return a Trelliscope data frame, but instead just specify a state. The `filter_*()` functions we have seen already.

For example, suppose we wish to add a view that only shows countries with minimum life expectancy greater than or equal to 60, sorted from highest to lowest minimum life expectancy:

```{r}
z <- z |>
  add_view(
    name = "Countries with high life expectancy (min >= 60)",
    filter_range("min_lifeexp", min = 60),
    state_sort("min_lifeexp", dir = "desc")
  )
```

You can add as many views as you would like by chaining more calls to `add_view()`.

#### `add_inputs()`

You can add user inputs that are attached to each panel of the display using the `add_inputs()` function. This function takes any number of arguments created by any of the following functions:

-   `input_radio(name, label, options)`
-   `input_checkbox(name, label, options)`
-   `input_select(name, label, options)`
-   `input_multiselect(name, label, options)`
-   `input_text(name, label, width, height)`
-   `input_number(name, label)`

These specify different input types.

For example, if we want a free text input for comments as well as yes/no question asking if the data looks correct for the panel, we can do the following:

```{r}
z <- z |>
  add_inputs(
    input_text(name = "comments", label = "Comments about this panel",
      width = 100, height = 6),
    input_radio(name = "looks_correct",
      label = "Does the data look correct?", options = c("no", "yes"))
  ) |>
  add_input_email("johndoe123@fakemail.net")
```

Let's see how all of these operations are reflected in our Trelliscope data frame:

```{r}
show_info(z)
```

#### Output

Now that we have built up our Trelliscope data frame, we can write it out as specified before with `write_trelliscope()`.

```{r}
write_trelliscope(z)
```

`list.files(disp$path)`

This writes the panels if they haven't been written yet, and then writes out a JSON representation of all of the other specifications we have made for the app to consume.

To see what the JSON representation of this looks like for the display we have been building:

```{r}
z |> as_json()
```
